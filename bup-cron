#! /usr/bin/python

# limitations
# * should do fsck and maybe compare-tree
# * some hardcoded stuff (-x, lvm snapshot size, snapshot
# mountpoint...)
# * supports only LVM, assumes POSIX (so no Windows)
# * should be unit tested, at this point it's grown too big
# * see XXX below for more

import os
import sys
import subprocess
import socket
import argparse
import re
import stat
import time
import datetime
import errno

class SaferFileType(argparse.FileType):
    """Factory for creating file object types

    This replacement is necessary for two reasons:

    * '-' and mode='a' conflict
    * crashes if logfile cannot be opened, which breaks usage
    """
    def __call__(self, string):
        if string == '-' and 'a' in self._mode:
            self._mode = self._mode.replace('a', 'w')
        try:
            return argparse.FileType.__call__(self, string)
        except argparse.ArgumentTypeError as e:
            sys.stderr.write(str(e) + "\n")
            return sys.stdout

class ArgumentConfigParser(argparse.ArgumentParser):
    configs = ['/etc/bup-cron.conf', '~/.bup-cron.conf']
    epilog = """options can also be specified, without --, in %s. an
    arbitrary configuration file may also be supplied on the
    commandline with a @ prefix (e.g. @foo.conf).

    at least path and repo need to be specified.
"""
    description = 'simple wrapper around bup and LVM'
    pidfile = '.bup-cron.pid'

    def __init__(self):
        argparse.ArgumentParser.__init__(self,
                                         description=self.description,
                                         epilog=self.epilog % " or ".join(self.configs),
                                         fromfile_prefix_chars='@')
        self.add_argument('-v', '--verbose', action='count',
                         help='output more information on console. tries to be silent if not specified. -v implies explaining what we do, -vv shows output of commands, -vvv passes verbose to those commands')
        # using the hostname as branch name
        self.add_argument('-n', '--name', default=socket.gethostname(),
                            help='name of the backup passed to bup, defaults to hostname (%s)' % socket.gethostname())
        self.add_argument('-l', '--logfile', default=sys.stdout, dest='log',
                          type=SaferFileType(mode='a', bufsize=1),
                            help='file where logs should be written, defaults to stdout')
        self.add_argument('--pidfile', default=None, action='store',
                          help='lockfile to write to avoid simultanous execution, defaults to $BUP_DIR/%s' % self.pidfile)
        self.add_argument('--clear', action='store_true',
                            help='redo a full backup (runs bup index --clear before starting)')
        self.add_argument('-s', '--snapshot', nargs='?', const='lvm', choices=['lvm'],
                            help='snapshot filesystem before backup. this will automatically guess the path to the logical volume (if relevant) and create a snapshot, mount it, then remove it when it is done.')
        self.add_argument('-x', '--exclude', action='append',
                            help='exclude regex pattern, will be passed as --exclude-rx to bup')
        if 'BUP_DIR' in os.environ:
            defdir = os.environ['BUP_DIR']
        else:
            defdir = None
        self.add_argument('-r', '--repository',
                          required=('BUP_DIR' not in os.environ),
                          default = defdir,
                          help='the directory to backup to, defaults to $BUP_DIR (currently %s)' % defdir)
        # different list because dest=paths doesn't work, it gets
        # overwritten by the next one
        # XXX: we'd like to not see this in the usage as well, as it's
        # for the config file
        self.add_argument('-p', '--path', action='append',
                            help='add path to list of paths to backup, mostly useful for the configuration file')
        # XXX: this should be mandatory, or at least --path or --paths should
        self.add_argument('paths', nargs='*', help='list of paths to backup')

    def convert_arg_line_to_args(self, arg_line):
        """parse a config file that looks like this:
"""
        # skip whitespace and commented lines
        if re.match('^(#|[\s]*$)', arg_line):
            return []
        else:
            # all lines are assumed to be options
            return ['--' + arg_line]

    def parse_args(self):
        configs = map(lambda x: os.path.expanduser(x), self.configs)
        for conf in configs:
            try:
                with open(conf, 'r'):
                    sys.argv.insert(1, '@' + conf)
            except IOError:
                pass
        args = argparse.ArgumentParser.parse_args(self)
        # merge the path and paths arguments
        if args.path:
            args.paths += args.path
        # remove this one to avoid ambiguity
        del args.path
        os.environ['BUP_DIR'] = args.repository
        # remove this one to avoid ambiguity
        del args.repository
        if args.pidfile is None:
            args.pidfile = os.path.join(os.environ['BUP_DIR'], self.pidfile)
        return args

def logfmt(msg):
    return "%s %s\n" % (time.ctime(), msg)

def log(msg, level=1):
    """log message to stdout or logfile, depending on --log"""
    if args.verbose >= level:
        args.log.write(logfmt(msg))

def warn(msg):
    # if log is a file, copy there
    if not args.log.isatty():
        log(msg, 0)
    sys.stderr.write(logfmt(msg))

def bail(status,msg=None):
    """cleanup on exit"""
    global start
    clean_lv()
    if msg:
        warn(msg)
    utimes = 'user %s system %s chlduser %s chldsystem %s' % os.times()[:4]
    log('finished in %s (%s)' % (str(datetime.datetime.now() - start), utimes))
    args.log.close()
    sys.exit(status)

def init():
    """initialise the repo and do other housecleaning"""
    global start
    start = datetime.datetime.now()
    log('backing up %s to %s' % (" ".join(args.paths), os.environ['BUP_DIR']))
    try:
        os.chdir(os.environ['BUP_DIR'])
    except OSError:
        log('bup dir not found, creating')
        check_call_log(['bup', 'init'])
    else:
        if args.clear:
            log('clearing log')
            check_call_log(['bup', 'index', '--clear'])

def check_call_log(cmd):
    """call a procss, log it to the logfile and return false if it fails, otherwise true"""
    try:
        log('calling command `%s`' % " ".join(cmd), 2)
        if args.verbose > 1:
            stdout = args.log
        else:
            stdout = file(os.devnull)
        subprocess.check_call(cmd, stdout=stdout, stderr=args.log, close_fds=True)
    except subprocess.CalledProcessError:
        warn('command failed')
        return False
    return True

def find_device(path):
    """find device based on mountpoint path, return the re.match (so None if not found)"""
    mounts = subprocess.check_output(['mount'])
    try:
        return re.match(r".*^(/[^ ]*) on %s .*" % path, mounts, re.MULTILINE | re.DOTALL).group(1)
    except:
        return False

def find_vg_lv(device):
    try:
        lvs = subprocess.check_output(['lvs', device], close_fds=True)
    except subprocess.CalledProcessError:
        # not a LVM
        return False
    # second line of output, second and third fields, backwards
    return re.split(r' +', re.split("\n", lvs)[1])[2:0:-1]

def snapname(lv):
    return 'snap%s' % lv

# XXX: won't work across multiple VGs with conflicting LV names
def snapmount(name):
    return '/media/bup/%s' % name

def lvdev(vg, lv):
    return '/dev/%s/%s' % ( vg, lv )

def clean_lv():
    if args.snapshot and vg and lv:
        m = snapmount(snapname(lv))
        if os.path.ismount(m) and not check_call_log(['umount', m]):
            warn('failed to umount %s' % m)
        try:
            log('removing directory %s' % m)
            os.removedirs(m)
        except:
            pass
        device = lvdev(vg, snapname(lv))
        try:
            cmd = ['lvremove', '-f', device]
            if args.verbose < 1:
                cmd += [ '-q' ]
            if args.verbose > 1:
                cmd += [ '-v' ]
            if stat.S_ISBLK(os.stat(device).st_mode) and not check_call_log(cmd):
                warn('failed to drop snapshot %s' % device)
        except OSError as e:
            # normal: the device doesn't exist, moving on
            return

def process(args):
    global vg, lv
    for path in args.paths:
        if args.snapshot:
            vg = lv = None
            # XXX: all of this should be moved to a Snapshot class, subclassed as LvmSnapshot
            # it can then be instantiated depending on the value of args.snapshot
            if os.path.ismount(path):
                device = find_device(path)
                if device:
                    lvs = find_vg_lv(device)
                if device and lvs:
                    vg = lvs[0]
                    lv = lvs[1]
                    log('umounting and removing previous snapshot %s, if present (errors ignored)' % lvdev(vg, snapname(lv)))
                    clean_lv()
                    # XXX: snapshot size hardcoded
                    cmd = ['lvcreate', '--size', '1GB', '--snapshot', '-n', snapname(lv), device]
                    if args.verbose < 1:
                        cmd += [ '-q' ]
                    if args.verbose > 1:
                        cmd += [ '-v' ]
                    if check_call_log(cmd):
                        try:
                            os.chdir(snapmount(snapname(lv)))
                        except OSError:
                            log('creating missing mountpoint %s' % snapmount(snapname(lv)))
                            os.makedirs(snapmount(snapname(lv)))
                        if check_call_log(['mount', lvdev(vg, snapname(lv)), snapmount(snapname(lv))]):
                            path = snapmount(snapname(lv))
                        else:
                            warn('failed to mount snapshot %s on %s, skipping snapshotting' % (snapname(lv), snapmount(snapname(lv))))
                            lv = vg = None
                    else:
                        warn('failed to create snapshot for LV %s on VG %s, skipping snapshooting' % (lv, vg))
                        lv = vg = None
                else:
                    # XXX: we could try to find the parent mountpoint...
                    warn('%s is not a LVM mountpoint, skipping snapshotting' % path)
            else:
                warn('%s is not a mountpoint, skipping snapshotting' % path)

        # XXX: this shouldn't be in the loop like this, bup index should be
        # able to index multiple paths
        #
        # unfortunately, `bup index -x / /var` skips /var...
        log('indexing %s' % path)
        # XXX: should be -q(uiet) unless verbose > 0 - but bup index has no -q
        cmd = ['bup', 'index']
        if args.verbose > 1:
            cmd += [ '-v' ]
        if args.exclude:
            cmd += map((lambda ex: '--exclude-rx=' + ex), args.exclude)
        # XXX: -x hardcoded?
        cmd += [ '-x', path ]
        if not check_call_log(cmd):
            warn('skipping save because index failed!')
            clean_lv()
            continue
        log('saving %s' % path)
        # XXX: should be -q(uiet) unless verbose > 0
        cmd = ['bup', 'save']
        if args.verbose > 1:
            cmd += [ '-v' ]
        # XXX: this should just be args.name, but we save once per path so
        # it's cleaner to group by path
        #  -c and -t are apparently useful in case of disaster
        cmd += [ '-c', '-t', '--strip', '-n', args.name + '-' + path, path ]
        check_call_log(cmd)
        clean_lv()

class Pidfile():
    def __init__(self, path, log=sys.stdout.write, warn=sys.stderr.write):
        self.pidfile = path
        self.log = log
        self.warn = warn

    def __enter__(self):
        try:
            self.pidfd = os.open(self.pidfile, os.O_CREAT|os.O_WRONLY|os.O_EXCL)
            self.log('locked pidfile %s' % self.pidfile)
        except OSError as e:
            if e.errno == errno.EEXIST:
                pid = self._check()
                if pid:
                    self.pidfd = None
                    raise ProcessRunningException('process already running in %s as pid %s' % (self.pidfile, pid));
                else:
                    os.remove(self.pidfile)
                    self.warn('removed staled lockfile %s' % (self.pidfile))
                    self.pidfd = os.open(self.pidfile, os.O_CREAT|os.O_WRONLY|os.O_EXCL)
            else:
                raise

        os.write(self.pidfd, str(os.getpid()))
        os.close(self.pidfd)
        return self

    def __exit__(self, t, e, tb):
        # return false to raise, true to pass
        if t is None:
            # normal condition, no exception
            self._remove()
            return True
        elif t is PidfileProcessRunningException:
            # do not remove the other process lockfile
            return False
        else:
            # other exception
            if self.pidfd:
                # this was our lockfile, removing
                self._remove()
            return False

    def _remove(self):
        self.log('removed pidfile %s' % self.pidfile)
        os.remove(self.pidfile)

    def _check(self):
        """check if a process is still running

the process id is expected to be in pidfile, which should exist.

if it is still running, returns the pid, if not, return False."""
        with open(self.pidfile, 'r') as f:
            try:
                pidstr = f.read()
                pid = int(pidstr)
            except ValueError:
                # not an integer
                self.log("not an integer: %s" % pidstr)
                return False
            try:
                os.kill(pid, 0)
            except OSError:
                self.log("can't deliver signal to %s" % pid)
                return False
            else:
                return pid


class ProcessRunningException(BaseException):
    pass

def main():
    global args, pidfd
    # XXX: this should be a "with", but first we need bup index to work properly before refactoring
    args = ArgumentConfigParser().parse_args()
    init()
    try:
        with Pidfile(args.pidfile, log, warn):
            process(args)
    except:
        #t, e, b = sys.exc_info()
        #warn(traceback.print_tb(b))
        # get exception type and error, but don't generate the traceback
        t, e = sys.exc_info()[:2]
        warn('aborting with %s exception: %s' % (t.__name__, e))
        # wait for bup to finish
        os.wait()
        bail(1)
    finally:
        bail(0)

if __name__ == '__main__':
    main()
