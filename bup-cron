#! /usr/bin/python

"""
simple wrapper around bup index and save designed to be ran in cron
jobs, with support for filesystem snapshots, logging and configuration
files.
"""

"""
limitations
 * assumes POSIX (so no Windows)
 * should be unit tested, at this point it's grown too big
 * see XXX below for more

features missing
 * --test to run compare-tree after backup
 * support for BTRFS, ZFS, etc
"""

import os
import sys
import subprocess
import socket
import argparse
import re
import stat
import time
import datetime
import errno


class ArgumentConfigParser(argparse.ArgumentParser):
    configs = ['/etc/bup-cron.conf', '~/.bup-cron.conf']
    epilog = """options can also be specified, without --, in %s. an
    arbitrary configuration file may also be supplied on the
    commandline with a @ prefix (e.g. @foo.conf).

    at least path and repo need to be specified.
"""
    description = __doc__
    pidfile = '.bup-cron.pid'

    def __init__(self):
        """various settings for the argument parser"""
        argparse.ArgumentParser.__init__(self,
                                         description=self.description,
                                         epilog=self.epilog %
                                         " or ".join(self.configs),
                                         fromfile_prefix_chars='@')
        self.add_argument('-v', '--verbose', action='count',
                          help="""output more information on console.
tries to be silent if not specified.
-v implies explaining what we do,
-vv shows output of commands,
-vvv passes verbose to those commands""")
        # using the hostname as branch name
        self.add_argument('-n', '--name', default=socket.gethostname(),
                          help="""name of the backup passed to bup,
defaults to hostname (%(default)s)""")
        self.add_argument('-l', '--logfile', default=sys.stdout, dest='log',
                          type=SaferFileType(mode='a', bufsize=1),
                          help="""file where logs should be written,
defaults to stdout""")
        self.add_argument('--pidfile', default=None, action='store',
                          help="""lockfile to write to avoid simultanous
execution, defaults to $BUP_DIR/%s"""
                          % self.pidfile)
        self.add_argument('-s', '--snapshot', nargs='?',
                          const='lvm', choices=['lvm'],
                          help="""snapshot filesystem before backup.
this will automatically guess the path to the logical volume,
create a snapshot, mount it, then remove it when it is done.""")
        self.add_argument('-z', '--size', action='store',
                          default=Snapshot.size,
                          help="""size of the LVM snapshot,
defaults to %(default)s""")
        self.add_argument('--clear', action='store_true',
                          help="""redo a full backup
(runs bup index --clear before starting)""")
        self.add_argument('-x', '--exclude', action='append',
                          help="""exclude regex pattern,
will be passed as --exclude-rx to bup""")
        self.add_argument('--parity', action='store_true',
                          help="""generate recovery blocks after backup.
runs bup fsck -g after the backup, requires par2(1).""")
        if 'BUP_DIR' in os.environ:
            defdir = os.environ['BUP_DIR']
        else:
            defdir = None
        self.add_argument('-r', '--repository',
                          required=('BUP_DIR' not in os.environ),
                          default = defdir,
                          help="""the directory to backup to,
defaults to $BUP_DIR (%s)"""
                          % defdir)
        # different list because dest=paths doesn't work, it gets
        # overwritten by the next one
        # XXX: we'd like to not see this in the usage as well, as it's
        # for the config file
        self.add_argument('-p', '--path', action='append',
                          help="""add path to list of paths to backup,
mostly useful for the configuration file""")
        # XXX: this should be mandatory, or at least --path or --paths should
        self.add_argument('paths', nargs='*', help='list of paths to backup')

    def convert_arg_line_to_args(self, arg_line):
        """parse a config file that looks like this:
"""
        # skip whitespace and commented lines
        if re.match('^(#|[\s]*$)', arg_line):
            return []
        else:
            # all lines are assumed to be options
            return ['--' + arg_line]

    def parse_args(self):
        """process argument list

inject system and user config files and cleanup various arguments and
defaults that couldn't be done otherwise"""
        configs = map(lambda x: os.path.expanduser(x), self.configs)
        for conf in configs:
            try:
                with open(conf, 'r'):
                    sys.argv.insert(1, '@' + conf)
            except IOError:
                pass
        args = argparse.ArgumentParser.parse_args(self)
        # merge the path and paths arguments
        if args.path:
            args.paths += args.path
        # remove this one to avoid ambiguity
        del args.path
        os.environ['BUP_DIR'] = args.repository
        # remove this one to avoid ambiguity
        del args.repository
        if args.pidfile is None:
            args.pidfile = os.path.join(os.environ['BUP_DIR'], self.pidfile)
        return args


class SaferFileType(argparse.FileType):
    """Factory for creating file object types

    This replacement is necessary for two reasons:

    * '-' and mode='a' conflict
    * crashes if logfile cannot be opened, which breaks usage
    """
    def __call__(self, string):
        """override parent to get the behavior we want"""
        if string == '-' and 'a' in self._mode:
            self._mode = self._mode.replace('a', 'w')
        try:
            return argparse.FileType.__call__(self, string)
        except argparse.ArgumentTypeError as e:
            sys.stderr.write(str(e) + "\n")
            return sys.stdout


class Snapshot():
    # default snapshot size
    size = '1GB'

    # the location the snapshot is mounted on
    mountpattern = '/media/bup/%s-%s'

    def __init__(self, path, size, log=sys.stdout.write, warn=sys.stderr.write,
                 verbose=0, call=subprocess.check_call, mountpattern=None):
        """initialise the snapshot array

path is expected to be the root of the filesystem
log and warn are logging utilities
call is a way to call processes that will return true on success or
false otherwise"""
        self.path = path
        self.size = size
        self.log = log
        self.warn = warn
        self.verbose = verbose
        self.call = call
        if mountpattern is not None:
            self.mountpattern = mountpattern

    def __enter__(self):
        """this should be reimplemented by subclasses

this should:

1. create a snapshot
2. mount it in a specific location
3. set that location in self.path, or leave the original path in place
otherwise"""
        return self

    def __exit__(self, t, e, tb):
        # return false to raise, true to pass
        self.cleanup()
        return t is None

    def cleanup(self):
        """this function should undo all that __enter__() did"""
        pass


class LvmSnapshot(Snapshot):
    def __enter__(self):
        """set the LVM and mount it"""
        self.vg_lv = None
        if os.path.ismount(self.path):
            device = self.find_device()
            if device:
                # vg, lv
                self.vg_lv = LvmSnapshot.find_vg_lv(device)
            if device and self.vg_lv:
                self.cleanup()
                cmd = ['lvcreate', '--size', self.size, '--snapshot',
                       '--name', self.snapname(), device]
                if self.verbose <= 0:
                    cmd += ['--quiet']
                if self.verbose >= 3:
                    cmd += ['--verbose']
                if self.call(cmd):
                    try:
                        os.chdir(self.mountpoint())
                    except OSError:
                        self.log('creating missing mountpoint %s'
                                 % self.mountpoint())
                        os.makedirs(self.mountpoint())
                    if self.call(['mount', self.device(),
                                  self.mountpoint()]):
                        self.path = self.mountpoint()
                    else:
                        self.warn("""failed to mount snapshot %s on %s,
skipping snapshotting"""
                                  % (self.snapname(),
                                     self.mountpoint()))
                else:
                    self.warn("""failed to create snapshot %s/%s,
skipping snapshooting"""
                              % self.vg_lv)
            else:
                # XXX: we could try to find the parent mountpoint...
                warn('%s is not a LVM mountpoint, skipping snapshotting'
                     % self.path)
        else:
            warn('%s is not a mountpoint, skipping snapshotting' % self.path)
        return self

    def find_device(self):
        """find device based on mountpoint path

        returns the device or False if none found"""

        mounts = subprocess.check_output(['mount'])
        try:
            return re.match(r".*^(/[^ ]*) on %s .*" % self.path, mounts,
                            re.MULTILINE | re.DOTALL).group(1)
        except:
            return False

    @staticmethod
    def find_vg_lv(device):
        """find the volume group and logical volume of the specified device"""
        try:
            lvs = subprocess.check_output(['lvs', device], close_fds=True)
        except subprocess.CalledProcessError:
            # not a LVM
            return False
        # second line of output, second and third fields, backwards
        return tuple(re.split(r' +', re.split("\n", lvs)[1])[2:0:-1])

    def snapname(self):
        """the name of the snapshot volume to be created

pattern should have two string wildcards, one for vg, the other for lv"""
        return 'snap%s' % self.vg_lv[1]

    def mountpoint(self):
        """where to mount the snapshot device"""
        return self.mountpattern % self.vg_lv

    def device(self):
        """path to the device of the snapshot LV"""
        return '/dev/%s/%s' % (self.vg_lv[0], self.snapname())

    def cleanup(self):
        """cleanup everything we did here"""
        if self.vg_lv is None:
            return
        m = self.mountpoint()
        # wait for bup to finish
        try:
            os.wait()
        except OSError as e:
            if e.errno == errno.ECHILD:  # no child process
                pass
            else:
                raise
        if os.path.ismount(m):
            if self.call(['umount', m]):
                self.log('umounted %s' % m)
            else:
                self.warn('failed to umount %s' % m)
        try:
            os.removedirs(m)
            self.log('removed directory %s' % m)
        except:
            pass
        device = self.device()
        try:
            # --force is required to avoid confirmation
            cmd = ['lvremove', '--force', device]
            if self.verbose <= 0:
                cmd += ['--quiet']
            if self.verbose >= 3:
                cmd += ['--verbose']
            if stat.S_ISBLK(os.stat(device).st_mode):
                if self.call(cmd):
                    self.log('dropped snapshot %s' % device)
                else:
                    self.warn('failed to drop snapshot %s' % device)
        except OSError:
            # normal: the device doesn't exist, moving on
            return


class Pidfile():
    """this class is designed to be used with the "with" construct

it will create an exclusive lockfile, detect existing ones and remove
stale files (with invalid pids or that the process disappeared)

it will also cleanup after itself"""

    def __init__(self, path, log=sys.stdout.write, warn=sys.stderr.write):
        """setup various parameters"""
        self.pidfile = path
        self.log = log
        self.warn = warn

    def __enter__(self):
        """wrapper around create() to work with the 'with' statement"""
        return self.create()

    def __exit__(self, t, e, tb):
        """remove the pid file, unless we detected another process"""
        # return false to raise, true to pass
        if t is None:
            # normal condition, no exception
            self.remove()
            return True
        elif t is ProcessRunningException:
            # do not remove the other process lockfile
            return False
        else:
            # other exception
            if self.pidfd:
                # this was our lockfile, removing
                self.remove()
            return False

    def create(self):
        """initialise pid file"""
        try:
            self.pidfd = os.open(self.pidfile,
                                 os.O_CREAT | os.O_WRONLY | os.O_EXCL)
            self.log('locked pidfile %s' % self.pidfile)
        except OSError as e:
            if e.errno == errno.EEXIST:
                pid = self._check()
                if pid:
                    self.pidfd = None
                    raise ProcessRunningException(self.pidfile, pid)
                else:
                    os.remove(self.pidfile)
                    self.warn('removed staled lockfile %s' % (self.pidfile))
                    self.pidfd = os.open(self.pidfile,
                                         os.O_CREAT | os.O_WRONLY | os.O_EXCL)
            else:
                raise

        os.write(self.pidfd, str(os.getpid()))
        os.close(self.pidfd)
        return self

    def remove(self):
        """helper function to actually remove the pid file"""
        self.log('removed pidfile %s' % self.pidfile)
        os.remove(self.pidfile)

    def _check(self):
        """check if a process is still running

the process id is expected to be in pidfile, which should exist.

if it is still running, returns the pid, if not, return False."""
        with open(self.pidfile, 'r') as f:
            try:
                pidstr = f.read()
                pid = int(pidstr)
            except ValueError:
                # not an integer
                self.log("not an integer: %s" % pidstr)
                return False
            try:
                os.kill(pid, 0)
            except OSError:
                self.log("can't deliver signal to %s" % pid)
                return False
            else:
                return pid


class ProcessRunningException(Exception):
    """an exception yielded by the Pidfile class when a process is
    detected using the pid file"""

    def __init__(self, path, pid):
        """override parent constructor to keep path and pid"""
        self.path = path
        self.pid = pid
        return Exception.__init(self, 'process already running in % as pid %s'
                                % (path, pid))


def logfmt(msg):
    """helper function to prepend time to messages"""
    return "%s %s\n" % (time.ctime(), msg)


def log(msg, level=1):
    """log message to stdout or logfile, depending on --log"""
    global __ARGS
    if __ARGS.verbose >= level:
        __ARGS.log.write(logfmt(msg))


def warn(msg):
    """log a warning to stderr and the logfile"""
    # if log is a file, copy there, otherwise stderr is enough
    global __ARGS
    if not __ARGS.log.isatty():
        log(msg, 0)
    sys.stderr.write(logfmt(msg))


def bail(status, msg=None):
    """cleanup on exit"""
    global __START, __ARGS
    if msg:
        warn(msg)
    utimes = 'user %s system %s chlduser %s chldsystem %s' % os.times()[:4]
    log('finished in %s (%s)'
        % (str(datetime.datetime.now() - __START), utimes))
    sys.exit(status)


def init():
    """initialise the repo and do other housecleaning"""
    global __START, __ARGS
    __START = datetime.datetime.now()
    log('backing up %s to %s'
        % (" ".join(__ARGS.paths), os.environ['BUP_DIR']))
    try:
        os.chdir(os.environ['BUP_DIR'])
    except OSError:
        log('bup dir not found, creating')
        check_call_log(['bup', 'init'])
    else:
        if __ARGS.clear:
            log('clearing log')
            check_call_log(['bup', 'index', '--clear'])


def check_call_log(cmd):
    """call a procss, log it to the logfile

return false if it fails, otherwise true"""
    global __ARGS
    try:
        log('calling command `%s`' % " ".join(cmd), 2)
        if __ARGS.verbose >= 2:
            stdout = __ARGS.log
        else:
            stdout = file(os.devnull)
        subprocess.check_call(cmd, stdout=stdout, stderr=__ARGS.log,
                              close_fds=True)
    except subprocess.CalledProcessError:
        warn('command failed')
        return False
    return True


def process(args):
    """main processing loop"""
    # current lvm object to cleanup in exception handlers
    for path in args.paths:
        with LvmSnapshot(path, args.size,
                         log, warn,
                         args.verbose, check_call_log) as l:
            path = l.path
            # XXX: this shouldn't be in the loop like this, bup index should be
            # able to index multiple paths
            #
            # unfortunately, `bup index -x / /var` skips /var...
            log('indexing %s' % path)
            # XXX: should be -q(uiet) unless verbose > 0 - but bup
            # index has no -q
            cmd = ['bup', 'index']
            if args.verbose >= 3:
                cmd += ['--verbose']
            if args.exclude:
                cmd += map((lambda ex: '--exclude-rx=' + ex), args.exclude)
            cmd += ['--one-file-system', path]
            if not check_call_log(cmd):
                warn('skipping save because index failed!')
                continue
            log('saving %s' % path)
            cmd = ['bup', 'save']
            if args.verbose <= 0:
                cmd += ['--quiet']
            if args.verbose >= 3:
                cmd += ['--verbose']
            # XXX: this should just be args.name, but we save once per path so
            # it's cleaner to group by path
            cmd += ['--strip', '--name', args.name + '-' + path, path]
            #  -c and -t are apparently useful in case of disaster
            # unfortunately, there are useless if we don't show the output
            if args.verbose >= 2:
                cmd += ['--commit', '--tree']
            check_call_log(cmd)
            if args.parity:
                if check_call_log(['bup', 'fsck', '--par2-ok']):
                    cmd = ['bup', 'fsck', '--generate']
                    if args.verbose >= 3:
                        cmd += ['--verbose']
                    log('generating par2(1) recovery blocks')
                    check_call_log(cmd)
                else:
                    warn("""bup reports par2(1) as not working,
no recovery blocks written""")


def main():
    """main entry point, sets up error handlers and parses arguments"""
    global __ARGS
    __ARGS = ArgumentConfigParser().parse_args()
    init()
    try:
        with Pidfile(__ARGS.pidfile, log, warn):
            process(__ARGS)
    except:
        #t, e, b = sys.exc_info()
        #warn(traceback.print_tb(b))
        # get exception type and error, but don't generate the traceback
        t, e = sys.exc_info()[:2]
        warn('aborting with %s exception: %s' % (t.__name__, e))
        bail(1)
    bail(0)

if __name__ == '__main__':
    main()
